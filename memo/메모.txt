데이터: 컴퓨터가 이해 할 수 있는 정적인 정보
명령어: 데이터를 제어하는 컴퓨터가 이해 할 수 있는 것

기계어/어셈블리어 = 저급언어
c언어,c++ = 고급언어

소스코드->목적코드

어셈블리어->디버깅 할 때 호출스택과 값이 정확한데 오류나는 경우 까봐야함
어셈블리어를 알아보기 힘들다->고급언어(컴퓨터는 모른다->컴파일러,인터프리터)

컴파일러는 파일단위
인터프리터는 줄단위->수정이 쉽다->수정을 안하면 다시 번역하지않기 때문(대신 느림)

명령어
대상,연산(what,how)

|연산필드|오퍼랜드필드|

오퍼랜드필드에서 보통은 주소가 온다(이유 오퍼랜드필드의 비트수만큼의 데이터를 표현하려면)

연산필드:
연산코드 유형
 산술논리연산:ADD,...,AND,OR,NOT,COMPARE
 데이터전송:move, store, load, push(메모리에다가 푸쉬), pop(메모리에 팝)
 제어흐름변경(분기문, 조건문):
JUMP, CONDITIONAL JUMP, CALL(되돌아올 주소 저장하고 분기), RETURN(CALL위치로 돌아감), HALT(프로그램실행 정지)
 입출력제어:READ, WRITE, START I/O, TEST I/O(입출력 장치 테스트)



오퍼랜드:
*유효주소 = 실제 데이터 저장 주소
	*명령어 주소 지정 방식

	1.즉시 주소지정방식=연산코드|연산에 쓸 데이터
		(간단한 연산,상수처리) (빠름)

	2.직접 주소지정방식 = 연산코드|유효주소
							->메모리의 값이 저장되어있는 실제주소
	(빠르고, 오버헤드가 없다) (단점으로 오퍼랜드필드의 크기에 제한적임)

	3.간접주소지정방식 = 연산코드|유효주소
							->메모리의 값이 저장되있는 주소를 가르키는 데이터가 저장되어있는 메모리주소
	(동적변경이 유용, 오퍼랜트 필드에 데이터값이 국한되어있지않음) 
	(메모리액세스가 많아져서 오래걸림)

	4.레지스터 주소지정방식 = 연산코드|유효주소(레지스터에 있는 데이터)
	(데이터를 메모리에서 읽는 것이 아닌 레지스터에 읽어옴=> 속도는 빠르지만 크기	가 작고 한정되어있다.)
	
	5.레지스터 간접 주소지정방식 = 연산코드|주소를 저장하는 레지스터주소
								-> 값을 저장하는 메모리의 주소
	(레지스터에서 메모리의 주소를 주기위해서 한번의 연산이 더필요하기에 성능저하)

	6.스택 주소지정방식 = 스택포인터가 가르키는 주소를 사용해서 접근하는 방법
		스택 메모리를 알아내고 스택이 얼만큼 있는지 맨위의 값이 무엇인지 알면 사용
	7.변위 주소지정방식 = 연산코드|레지스터|오퍼랜드
					->레지스터의 주소로부터 오퍼랜드를 offset으로 이용해서 주소로 사용
	  상대 주소지정방식 = 연산코드|PC|-1
					->PC가 가르키는 주소의 -1만큼의 주소가 오퍼랜드

(분기문(반복문,조건문))

CPU
ALU->
	피연산자 피연산자
	
제어신호->ALU<-플래그 레지스터

	      결과값
플래그들: 1비트씩 할당되어있는 비트
1.부호플래그
2.제로
3.캐리
4.오버플로우
5.인터럽트
6.슈퍼바이저

레지스터->
-프로그램 카운터(PC)=메모리에서 읽은 명령어의 메모리의 주소(분기문 제외 1씩증가하면서 명령어를 읽는다.)
-명령어 레지스터(IR)=현재 CPU해석, 처리하는 명령어를 저장하는 레지스터
-메모리 주소레지스터(MAR)=메모리를 읽은 주소를 저장하는 레지스터
-메모리 버퍼레지스터(MBR)=메모리에서 읽은 값,명령어를 저장하는 레지스터


명령어 사이클
-인출사이클
-실행사이클
-간접사이클
-인터럽트사이클

인터럽트
1.동기 인터럽트(오류났을 경우 오류 처리를 위한 인터럽트 처리)
2.비동기 인터럽트(일종의 알림)

서비스 루틴
인터럽트나 간접사이클이 발생하면 그것을 먼저 처리하고 인출 실행 사이클을 다시돌리는 일종의 사이클을 미리정해두는 약속






